# 问题描述

AB 实验同学每天都很苦恼如何可以更好地进行 AB 实验，每一步的流程很重要，我们目标为了缩短所需的步数。

我们假设每一步对应到每一个位置。从一个整数位置 `x` 走到另外一个整数位置 `y`，每一步的长度是正整数，每步的值等于上一步的值 `-1`， `+0`，`+1`。求 `x` 到 `y` 最少走几步。并且第一步必须是 `1`，最后一步必须是 `1`，从 `x` 到 `y` 最少需要多少步。

## 样例说明

- 整数位置 `x` 为 `12`，另外一个整数位置 `y` 为 `6`，我们需要从 `x` 走到 `y`，最小的步数为：`1`，`2`，`2`，`1`，所以我们需要走 `4` 步。
- 整数位置 `x` 为 `34`，另外一个整数位置 `y` 为 `45`，我们需要从 `x` 走到 `y`，最小的步数为：`1`，`2`，`3`，`2`，`2`，`1`，所以我们需要走 `6` 步。
- 整数位置 `x` 为 `50`，另外一个整数位置 `y` 为 `30`，我们需要从 `x` 走到 `y`，最小的步数为：`1`，`2`，`3`，`4`，`4`，`3`，`2`，`1`，所以我们需要走 `8` 步。

## 输入格式

输入包含 `2` 个整数 `x`，`y`。（`0<=x<=y<2^31`）

## 输出格式

对于每一组数据，输出一行，仅包含一个整数，从 `x` 到 `y` 所需最小步数。

## 输入样例

```
12 6
34 45
50 30
```

## 输出样例

```
4
6
8
```

# 解答

## 思路

对于这道题，我们的目标是找到从一个整数位置 `x` 走到另一个整数位置 `y` 的最少步数。

首先理解问题，我们要通过一系列步长为 `-1`、`0`、`1` 的步骤来实现从 `x` 到 `y` 的移动，且第一步和最后一步步长必须为 `1`。

数据结构方面，由于我们主要是进行数值的计算和比较，不需要特别复杂的数据结构。

算法步骤可以这样考虑：
1. 计算 `x` 和 `y` 的差值 `diff = y - x`。
2. 初始化步数 `step = 0` 和当前位置 `currentPosition = x`。
3. 从 `1` 开始逐步增加步长，直到当前位置超过或等于 `y`。
    - 如果当前位置加上步长小于 `y`，则增加步长并更新当前位置，步数加 `1`。
    - 如果当前位置加上步长大于 `y`，则将步长减 `1`，继续尝试。

## 代码

```cpp
#include <iostream>

int solution(int xPosition, int yPosition) {
    // Please write your code here
    return -2;
}

int main() {
    //  You can add more test cases here
    std::cout << (solution(12, 6) == 4) << std::endl;
    std::cout << (solution(34, 45) == 6) << std::endl;
    std::cout << (solution(50, 30) == 8) << std::endl;
    return 0;
}
```

```js
function solution(xPosition, yPosition) {
  // Please write your code here
  return -2;
}

function main() {
    // You can add more test cases here
    console.log(solution(12, 6) === 4);
    console.log(solution(34, 45) === 6);
    console.log(solution(50, 30) === 8);
}

main();
```